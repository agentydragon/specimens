rationale: |
  The `on_call_tool` method constructs 8 independent ToolCallRecord instances at lines 150-158,
  180-188, 195-205, 263-271, 278-286, 302-310, 317-327, and 339-347, each repeating the same
  4-7 field assignments (call_id, run_id, agent_id, tool_call, decision, execution).

  This massive code duplication (~100 lines of redundancy) violates DRY. Field assignments
  obscure the actual state transitions (PENDING → EXECUTING → COMPLETED, or DENIED paths).
  When fields change, all 8 constructions must be updated, making maintenance error-prone.

  Create ONE mutable ToolCallRecord instance at the start. At each state transition, update only
  the changed fields (set .decision or .execution), then save. This eliminates redundancy, makes
  state transitions explicit, and ensures single source of truth for record fields.

  Requires ToolCallRecord to be mutable (dataclass with frozen=False, or Pydantic with frozen=False).
should_flag: true
occurrences:
- occurrence_id: occ-0
  files:
    adgn/src/adgn/mcp/policy_gateway/middleware.py:
    - - 142
      - 358
    - - 150
      - 158
    - - 180
      - 188
    - - 195
      - 205
    - - 263
      - 271
    - - 278
      - 286
    - - 302
      - 310
    - - 317
      - 327
    - - 339
      - 347
  critic_scopes_expected_to_recall:
  - - adgn/src/adgn/mcp/policy_gateway/middleware.py
