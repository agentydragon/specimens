rationale: |
  The `parse_event()` function manually parses event dictionaries using if-elif
  chains that inspect the `type` field and construct the appropriate payload class.
  This is exactly what Pydantic's discriminated union parsing does automatically,
  but the code reimplements it by hand.

  **Current implementation (events.py, lines 67-100):**
  The code defines `TypedPayload` with `Field(discriminator=None)` and implements
  a 30+ line `parse_event()` function with manual if-elif dispatching for each
  event type (USER_TEXT, ASSISTANT_TEXT, TOOL_CALL, etc.), manually extracting
  fields from dictionaries and constructing payload objects.

  **Problems:**

  1. **Reimplements Pydantic**: Manual if-elif dispatching duplicates what Pydantic does
  2. **No validation**: Manual `str()` casts and `.get()` don't validate structure
  3. **Misleading type hint**: `Field(discriminator=None)` suggests discriminated union but doesn't use it

  **The correct approach:**

  Use Pydantic's discriminated union parsing: add `Literal["type"]` to each
  payload class, set `Field(discriminator="type")` on the union, and use
  `model_validate()`. This reduces the 30+ line manual parser to a 3-line
  function that injects the type field into the payload dict before validation.
should_flag: true
occurrences:
- occurrence_id: occ-0
  files:
    adgn/src/adgn/agent/persist/events.py:
    - - 47
      - 50
    - - 67
      - 100
  critic_scopes_expected_to_recall:
  - - adgn/src/adgn/agent/persist/events.py
