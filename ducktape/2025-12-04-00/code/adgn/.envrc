# direnv + devenv (cached) â€” recommended setup for adgn
# Note: NOT using source_up to avoid parent flake issues on virtiofs
# Load parent's nix packages directly
use nix -p pre-commit alejandra jsonnet

# Load devenv's direnv integration (provides caching + helpers)
eval "$(devenv direnvrc)"

# Trigger rebuilds only when dependency definitions change
watch_file pyproject.toml uv.lock devenv.nix

# Activate the devenv-managed uv environment
use devenv

# Activate the devenv-managed venv on PATH so python/pytest/etc. are available
export VIRTUAL_ENV="$PWD/.devenv/state/venv"
PATH_add "$VIRTUAL_ENV/bin"

# direnv shim wrappers (fallbacks; venv bin takes precedence)
PATH_add .direnv/bin

# Default registry endpoint for local pushes
export RSPCACHE_REGISTRY_HOST="registry.k3s.local"

# Props PostgreSQL setup (managed by devenv processes)
# Export database URLs (PostgreSQL started by `devenv up`)
# Admin: superuser for schema migrations and management
export PROPS_ADMIN_DB_URL="postgresql://postgres:postgres@localhost:5433/eval_results"
# Agent: read-only user with RLS restrictions (created by recreate_database())
export PROPS_AGENT_DB_URL="postgresql://agent_user:agent_password_changeme@localhost:5433/eval_results"
export PROPS_DB_URL="$PROPS_ADMIN_DB_URL"  # Default to admin for CLI tools
# Test: superuser required for schema setup/teardown
export PROPS_TEST_DB_URL="postgresql://postgres:postgres@localhost:5433/eval_results_test"

# Define convenience functions
props-db-snapshot() {
  local snapshot_dir="src/adgn/props/db/snapshots"
  local timestamp=$(date +%Y%m%d_%H%M%S)
  local snapshot_file="$snapshot_dir/props_${timestamp}.sql"

  mkdir -p "$snapshot_dir"

  echo "Creating database snapshot: $snapshot_file"
  docker exec props-postgres pg_dump -U postgres eval_results > "$snapshot_file"

  gzip -c "$snapshot_file" > "${snapshot_file}.gz"
  echo "Snapshot saved:"
  echo "  SQL: $snapshot_file ($(du -h "$snapshot_file" | cut -f1))"
  echo "  Compressed: ${snapshot_file}.gz ($(du -h "${snapshot_file}.gz" | cut -f1))"
}

props-db-restore() {
  if [ -z "$1" ]; then
    echo "Usage: props-db-restore <snapshot-file.sql[.gz]>"
    echo ""
    echo "Available snapshots (most recent first):"
    ls -1t src/adgn/props/db/snapshots/*.sql* 2>/dev/null | head -5
    return 1
  fi

  local snapshot_file="$1"

  if [[ "$snapshot_file" == *.gz ]]; then
    echo "Restoring from compressed snapshot: $snapshot_file"
    gunzip -c "$snapshot_file" | docker exec -i props-postgres psql -U postgres eval_results
  else
    echo "Restoring from snapshot: $snapshot_file"
    cat "$snapshot_file" | docker exec -i props-postgres psql -U postgres eval_results
  fi

  echo "Restore complete!"
}

# Check if PostgreSQL is ready and auto-initialize if needed
_check_postgres_ready() {
  if docker ps --format '{{.Names}}' | grep -q '^props-postgres$'; then
    # Check if running (health check not required)
    if docker inspect props-postgres --format "{{.State.Running}}" 2>/dev/null | grep -q true; then
      # Auto-initialize if no schema exists
      if ! docker exec props-postgres psql -U postgres -d eval_results -c "\dt" 2>/dev/null | grep -q "specimens"; then
        echo "No schema found. Running initialization..."
        adgn-properties db-recreate --yes
      fi
      echo "Props ready. Database: props-postgres (running)"
      echo "CLI: adgn-properties db-recreate --yes (drops all data)"
      return 0
    fi
  fi
  echo "Props setup ready. Start PostgreSQL with: devenv up"
  return 0
}

_check_postgres_ready
