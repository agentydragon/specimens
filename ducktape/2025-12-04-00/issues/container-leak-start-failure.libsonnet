{
  occurrences: [
    {
      expect_caught_from: [
        [
          'adgn/src/adgn/mcp/_shared/container_session.py',
        ],
      ],
      files: {
        'adgn/src/adgn/mcp/_shared/container_session.py': [
          {
            end_line: 174,
            start_line: 132,
          },
        ],
      },
      occurrence_id: 'occ-0',
    },
  ],
  rationale: "Lines 132-174 in _shared/container_session.py contain a critical container leak\nwhen container.start() fails after container.create() succeeds.\n\nThe vulnerable code path:\n\nasync def _start_container(...) -> dict[str, Any]:\n    container_config = opts.to_container_config(...)\n    container = await client.containers.create(container_config)  # ← CREATED\n    await container.start()  # ← If this FAILS, exception raised\n    return {\"Id\": container._id, \"Name\": \"\"}  # ← Never executes\n\ndef make_container_lifespan(opts: ContainerOptions):\n    @asynccontextmanager\n    async def lifespan(server: FastMCP):\n        client = await _init_docker()\n        container_dict = None  # ← Stays None if start fails\n        try:\n            if not opts.ephemeral:\n                container_dict = await _start_container(...)  # ← Assignment never completes\n            yield ContainerSessionState(...)\n        finally:\n            if container_dict is not None:  # ← False, so cleanup skipped!\n                # ... cleanup code never runs\n\nExact failure scenario:\n1. Line 135: client.containers.create() succeeds → container exists in Docker\n2. Line 136: container.start() fails (e.g., port conflict, resource limit,\n   invalid command, missing dependency)\n3. Exception raised from _start_container() → return never executes\n4. Line 151: Assignment never completes → container_dict remains None\n5. Line 163: Cleanup skipped because container_dict is None\n6. Result: Container leaked (created but not started, never cleaned up)\n\nWhy this is critical:\n- Container exists in Docker daemon consuming resources (memory, storage)\n- No reference exists to clean it up (container_dict was never set)\n- Accumulates on repeated failures (e.g., misconfigured service startup)\n- Not auto-removed (auto_remove=True only works for started containers)\n- Requires manual intervention: docker container prune\n\nRoot cause: Split responsibility between creation and lifecycle management.\nThe _start_container() helper owns creation+start but doesn't own cleanup,\nwhile the lifespan manager owns cleanup but can't clean up if the helper\nfails before returning the ID.\n\nSuggested fix: Use a context manager to tie container lifecycle to scope:\n\n@asynccontextmanager\nasync def scoped_container(\n    client: aiodocker.Docker,\n    opts: ContainerOptions\n) -> AsyncIterator[str]:\n    \"\"\"Create, start, and manage a Docker container's lifecycle.\n\n    Guarantees cleanup even if start fails. Yields container ID.\n    \"\"\"\n    container_config = opts.to_container_config(cmd=SLEEP_FOREVER_CMD, auto_remove=False)\n    container = await client.containers.create(container_config)\n    container_id = container.id\n\n    try:\n        await container.start()\n        yield container_id\n    finally:\n        # Always clean up, even if start failed\n        with anyio.CancelScope(shield=True):\n            try:\n                await container.kill()\n                await container.delete(force=True)\n            except Exception as e:\n                logger.error(f\"Container cleanup failed for {container_id}: {e}\")\n                raise\n\nThen simplify lifespan:\n\n@asynccontextmanager\nasync def lifespan(server: FastMCP):\n    client = await _init_docker()\n    try:\n        if not opts.ephemeral:\n            async with scoped_container(client, opts) as container_id:\n                yield ContainerSessionState(\n                    docker_client=client,\n                    container={\"Id\": container_id, \"Name\": \"\"},\n                    ...\n                )\n        else:\n            yield ContainerSessionState(\n                docker_client=client,\n                container=None,\n                ...\n            )\n    finally:\n        await client.close()\n\nBenefits:\n- Leak-proof: __aexit__ runs even if start() fails (container_id captured before start)\n- Clear ownership: Context manager owns entire container lifecycle\n- Composable: Can nest or chain context managers\n- Standard pattern: Follows Python context manager idioms\n- Simpler: Removes _start_container() helper, reducing indirection\n- Shield-wrapped: Cleanup protected from cancellation\n\nNote: aiodocker.containers.run() doesn't help - it combines create+start but\ndoesn't clean up on failure, just attaches container_id to the exception.\n",
  should_flag: true,
}
