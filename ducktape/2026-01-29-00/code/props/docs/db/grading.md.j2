# Grading Schema

## Bipartite Edge Model

Grading fills a bipartite graph between critique issues (left) and ground truth occurrences (right). **Every** (issue, matchable_occurrence) pair needs an edge:

| Critique Issue | GT Occurrence | Credit | Rationale |
|---------------|---------------|--------|-----------|
| input-001 | tp/dead-code/occ-0 | 1.0 | Exact match |
| input-001 | tp/security/occ-0 | 0.0 | Not related |
| input-001 | fp/known-pattern/occ-0 | 0.0 | Not triggered |
| input-002 | tp/dead-code/occ-0 | 0.5 | Partial match |

Each edge carries:
- **credit** (0.0-1.0): How well the issue matches the occurrence (0.0 = no match, 1.0 = perfect match)
- **rationale**: Your reasoning

**Sum constraint:** Each occurrence can receive at most 1.0 total credit across all issues.

{{ describe_relation("grading_edges") }}

## Pending Edges (Completeness)

{{ describe_relation("grading_pending") }}

**Source of truth for completeness:** Query `grading_pending` to see missing edges. Grading is complete when no rows remain. The grader submit MCP tool validates this and rejects submission if any edges are pending.

## Sparse Matching (graders_match_only_if_reported_on)

Not all occurrences are matchable from all critique issues. The `graders_match_only_if_reported_on` field on TP/FP occurrences controls which critiques can create edges to them:

| `graders_match_only_if_reported_on` | Meaning | Who can match |
|-------------------------------------|---------|---------------|
| null/omitted | Cross-cutting issue | Any critique can match, regardless of files touched |
| `["file1.py", "file2.py"]` | File-scoped issue | Only critiques that touched at least one file in that set |

The `grading_pending` view automatically enforces this - it only shows (issue, occurrence) pairs where the critique's files overlap.

{{ describe_relation("matchable_occurrences") }}
